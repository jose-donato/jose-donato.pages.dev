---
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from "@/components/pagination";

interface Props {
  pdfPath: string;
  workerPath?: string;
  title?: string;
}

const {
  pdfPath,
  workerPath = "//unpkg.com/pdfjs-dist@4.0.269/build/pdf.worker.min.mjs",
  title = "PDF Viewer",
} = Astro.props;
---

<div class="pdf-container">
  <pdf-viewer
    data-pdf-path={pdfPath}
    data-worker-path={workerPath}
    class="w-full"
  >
  </pdf-viewer>

  <div class="pdf-navigation mt-4">
    <div class="flex items-center justify-center gap-4">
      <button 
        id="prev-page"
        class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-border-focus h-10 px-4 py-2 gap-1 pl-2.5 hover:bg-bg-secondary text-text-secondary hover:text-text-primary disabled:opacity-50 disabled:cursor-not-allowed"
      >
        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
        </svg>
        <span>Previous</span>
      </button>
      
      <span id="current-page" class="flex items-center gap-2 px-4 py-2 text-sm">
        <span id="current-page-number">1</span>
        <span>/</span>
        <span id="total-pages">1</span>
      </span>
      
      <button 
        id="next-page"
        class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-border-focus h-10 px-4 py-2 gap-1 pr-2.5 hover:bg-bg-secondary text-text-secondary hover:text-text-primary disabled:opacity-50 disabled:cursor-not-allowed"
      >
        <span>Next</span>
        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<script
  is:inline
  src="https://unpkg.com/pdfjs-dist@4.0.269/build/pdf.min.mjs"
  type="module"></script>

<script>
  declare global {
    interface Window {
      pdfjsLib?: any;
    }
  }

  class PDFViewer extends HTMLElement {
    pdfPath;
    workerPath;
    loadingTask: any | null = null;
    canvas;
    pdfDocument: any = null;
    currentPage = 1;
    totalPages = 0;

    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.pdfPath = this.getAttribute("data-pdf-path");
      this.workerPath = this.getAttribute("data-worker-path");
      this.canvas = document.createElement("canvas");
      this.canvas.setAttribute("id", "pdf-canvas");
      this.canvas.style.width = "100%";
      this.canvas.style.height = "auto";
      this.canvas.style.border = "1px solid #ddd";
      this.canvas.style.borderRadius = "4px";
      this.canvas.style.direction = "ltr";

      const style = document.createElement("style");
      style.textContent = `
        :host {
          display: block;
          width: 100%;
          margin: 0 auto;
        }
        canvas {
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
      `;

      this.shadowRoot?.append(style, this.canvas);
    }

    async renderPage(pageNum: number) {
      if (!this.pdfDocument) return;

      this.currentPage = pageNum;

      // Request the page
      const pdfPage = await this.pdfDocument.getPage(pageNum);

      // Display page with responsive scaling
      const viewport = pdfPage.getViewport({ scale: 1.0 });
      const ctx = this.canvas.getContext("2d");

      if (!this.canvas || !ctx) {
        return;
      }

      // Set canvas dimensions to match the viewport
      this.canvas.width = viewport.width;
      this.canvas.height = viewport.height;

      // Clear canvas before rendering
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Render PDF page into canvas context
      const renderTask = pdfPage.render({
        canvasContext: ctx,
        viewport,
      });

      await renderTask.promise;
      this.updatePaginationUI();
    }

    updatePaginationUI() {
      // Update current page and total pages display
      const currentPageSpan = document.getElementById("current-page-number");
      const totalPagesSpan = document.getElementById("total-pages");

      if (currentPageSpan) {
        currentPageSpan.textContent = this.currentPage.toString();
      }
      if (totalPagesSpan) {
        totalPagesSpan.textContent = this.totalPages.toString();
      }

      const paginationPages = document.getElementById("pagination-pages");
      // Skip pagination pages creation if element doesn't exist - we're using simple buttons now

      if (paginationPages) {
        paginationPages.innerHTML = "";

      // Create pagination based on total pages
      const displayPages = Math.min(this.totalPages, 5);
      let startPage = Math.max(1, this.currentPage - 2);
      let endPage = Math.min(this.totalPages, startPage + displayPages - 1);

      // Adjust start page if we're near the end
      if (endPage - startPage < displayPages - 1) {
        startPage = Math.max(1, endPage - displayPages + 1);
      }

      // Add first page if not included in range
      if (startPage > 1) {
        const item = document.createElement("pagination-item");
        const link = document.createElement("pagination-link");
        link.setAttribute("href", "#");
        link.textContent = "1";
        link.addEventListener("click", (e) => {
          e.preventDefault();
          this.renderPage(1);
        });
        item.appendChild(link);
        paginationPages.appendChild(item);

        if (startPage > 2) {
          const ellipsis = document.createElement("pagination-item");
          const ellipsisContent = document.createElement("pagination-ellipsis");
          ellipsis.appendChild(ellipsisContent);
          paginationPages.appendChild(ellipsis);
        }
      }

      // Add page numbers
      for (let i = startPage; i <= endPage; i++) {
        const item = document.createElement("pagination-item");
        const link = document.createElement("pagination-link");
        link.setAttribute("href", "#");
        if (i === this.currentPage) {
          link.setAttribute("isActive", "true");
        }
        link.textContent = i.toString();
        link.addEventListener("click", (e) => {
          e.preventDefault();
          this.renderPage(i);
        });
        item.appendChild(link);
        paginationPages.appendChild(item);
      }

      // Add last page if not included in range
      if (endPage < this.totalPages) {
        if (endPage < this.totalPages - 1) {
          const ellipsis = document.createElement("pagination-item");
          const ellipsisContent = document.createElement("pagination-ellipsis");
          ellipsis.appendChild(ellipsisContent);
          paginationPages.appendChild(ellipsis);
        }

        const item = document.createElement("pagination-item");
        const link = document.createElement("pagination-link");
        link.setAttribute("href", "#");
        link.textContent = this.totalPages.toString();
        link.addEventListener("click", (e) => {
          e.preventDefault();
          this.renderPage(this.totalPages);
        });
        item.appendChild(link);
        paginationPages.appendChild(item);
      }
      } // Close the if (paginationPages) block

      // Update prev/next buttons state
      const prevButton = document.getElementById("prev-page") as HTMLButtonElement;
      const nextButton = document.getElementById("next-page") as HTMLButtonElement;

      if (prevButton) {
        prevButton.disabled = this.currentPage <= 1;
      }

      if (nextButton) {
        nextButton.disabled = this.currentPage >= this.totalPages;
      }
    }

    async load() {
      if (!this.loadingTask) return;

      try {
        this.pdfDocument = await this.loadingTask.promise;
        this.totalPages = this.pdfDocument.numPages;

        // Render first page
        await this.renderPage(1);
        
        // Set up pagination controls after rendering
        this.setupPaginationControls();
      } catch (error) {
        console.error("Error loading PDF document:", error);
      }
    }

    setupPaginationControls() {
      const prevButton = document.getElementById("prev-page") as HTMLButtonElement;
      const nextButton = document.getElementById("next-page") as HTMLButtonElement;

      if (prevButton) {
        prevButton.onclick = (e) => {
          e.preventDefault();
          if (this.currentPage > 1) {
            this.renderPage(this.currentPage - 1);
          }
        };
        
        // Set initial state
        prevButton.disabled = this.currentPage <= 1;
      }

      if (nextButton) {
        nextButton.onclick = (e) => {
          e.preventDefault();
          if (this.currentPage < this.totalPages) {
            this.renderPage(this.currentPage + 1);
          }
        };
        
        // Set initial state  
        nextButton.disabled = this.currentPage >= this.totalPages;
      }
    }

    handleLoaded() {
      // Wait for pdfjsLib to be available
      if (!window.pdfjsLib) {
        setTimeout(() => this.handleLoaded(), 100);
        return;
      }
      
      try {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = this.workerPath;
        this.loadingTask = window.pdfjsLib.getDocument(this.pdfPath);
        this.load();
      } catch (error) {
        console.error("Error loading PDF:", error);
      }
    }

    connectedCallback() {
      if (!this.pdfPath || !this.workerPath) return;

      // Check if DOM is already loaded
      if (document.readyState === 'loading') {
        window.addEventListener("DOMContentLoaded", this.handleLoaded.bind(this));
      } else {
        // DOM is already loaded, call handleLoaded immediately
        this.handleLoaded();
      }
    }

    disconnectedCallback() {
      window.removeEventListener(
        "DOMContentLoaded",
        this.handleLoaded.bind(this),
      );
    }
  }

  customElements.define("pdf-viewer", PDFViewer);

  // Define custom elements for pagination
  customElements.define("pagination-item", class extends HTMLElement {});
  customElements.define(
    "pagination-link",
    class extends HTMLElement {
      static get observedAttributes() {
        return ["isActive"];
      }

      constructor() {
        super();
        this.style.display = "inline-flex";
        this.style.alignItems = "center";
        this.style.justifyContent = "center";
        this.style.cursor = "pointer";
        this.style.padding = "0.5rem";
        this.style.margin = "0 0.25rem";
        this.style.borderRadius = "0.375rem";
        this.style.transition = "background-color 0.2s";
      }

      attributeChangedCallback(name, oldValue, newValue) {
        if (name === "isActive" && newValue === "true") {
          this.style.backgroundColor = "rgb(229, 231, 235)";
          this.style.fontWeight = "bold";
        } else {
          this.style.backgroundColor = "transparent";
          this.style.fontWeight = "normal";
        }
      }
    },
  );
  customElements.define(
    "pagination-ellipsis",
    class extends HTMLElement {
      constructor() {
        super();
        this.textContent = "...";
        this.style.display = "inline-flex";
        this.style.alignItems = "center";
        this.style.justifyContent = "center";
        this.style.padding = "0.5rem";
      }
    },
  );
</script>

<style>
  .pdf-container {
    margin: 2rem 0;
    width: 100%;
  }

  .pdf-navigation {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
  }
</style>
